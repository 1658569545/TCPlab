Lab 3 Writeup
=============


## 文档翻译
负责实现TCP的发送端

发送端会从ByteStream中读取数据，并将其转换为一系列的TCP端传出，并且会获取TCP接收方发送过来的窗口通知和ACK确认号

TCPSender的主要任务：
1. 跟踪接收方的窗口（处理传入的确认号（acknos）和窗口大小）
2. 在可能的情况下填充窗口，通过从 ByteStream 中读取数据，创建新的 TCP 报文段（如果需要，包含 SYN 和 FIN 标志），并发送它们
3. 跟踪已经发送但尚未被接收方确认的报文段——我们称这些为“未确认”报文段
4. 如果经过足够的时间仍未收到确认，则重新发送这些未确认的报文段

为什么我要这么做？基本原则是发送接收方允许我们发送的内容（填充窗口），并持续重新发送，直到接收方确认每个报文段。这被称为“自动重传请求”（ARQ）。发送方将字节流划分为报文段并发送，尽可能多地发送，直到接收方的窗口允许为止。
我们知道只要远程 TCP 接收方至少接收到每个带有索引标签的字节一次——不管顺序如何，它就能重组字节流。发送方的任务是确保接收方至少接收到每个字节一次。

## 什么时候TCPSender应该得出数据段丢失的结论并进行重传
 TCPSender 将发送一系列的 TCPSegments。每个报文段会包含一个来自发送字节流（ByteStream）的（可能为空的）子串，并通过序列号来标记它在字节流中的位置。报文段还会在流的开头标记 SYN 标志，在流的末尾标记 FIN 标志。
 除了发送这些报文段，TCPSender 还需要跟踪它的未确认报文段，直到这些报文段占据的序列号被完全确认。周期性地，TCPSender 的所有者会调用 TCPSender 的 tick 方法，以表示时间的流逝。TCPSender 需要查看它的未确认 TCPSegments 集合，并判断是否最早发送的报文段已经超时太久没有被确认（即，它的所有序列号都没有被确认）。如果是，它就需要重新传输（再次发送）该报文段。

1. 每隔几毫秒，TCPSender 的 tick 方法将被调用，并且会传入一个参数，指示自上次调用该方法以来经过了多少毫秒。你需要利用这个时间信息来维护 TCPSender 已经存活的总毫秒数。请不要尝试调用操作系统或 CPU 提供的任何“时间”或“时钟”函数——tick 方法是你获取时间流逝的唯一途径。这样可以保证程序的确定性和可测试性。

2. 当 TCPSender 被构造时，它会接收一个参数，告诉它“重传超时（RTO）的初始值”。RTO 是指在重新发送一个未确认的 TCP 报文段之前要等待的毫秒数。RTO 的值会随着时间的推移而变化，但“初始值”保持不变。初始值会被保存在一个名为 initial_retransmission_timeout 的成员变量中。

3. 你将实现重传定时器：一个可以在某个时间启动的警报，且当 RTO 时间经过后，警报会触发（或“过期”）。我们强调，这个时间流逝的概念来自于 tick 方法的调用——而不是通过获取实际的当前时间。

4. 每当发送一个包含数据（序列空间中非零长度）的报文段（无论是第一次发送还是重传），如果定时器没有运行，则启动定时器，使其在 RTO 毫秒后到期（对于当前的 RTO 值）。

5. 当所有未确认的数据都被确认后，关闭重传定时器。

6. 如果 tick 被调用且重传定时器已过期： (a) 重传最早（序列号最小）的一个尚未被 TCP 接收方完全确认的报文段。你需要在某个内部数据结构中存储未确认的报文段，以便进行这一操作。 (b) 如果窗口大小不为零： i. 追踪连续的重传次数，并将其增加，因为你刚刚重传了某个报文段。你的 TCPConnection 将使用这一信息来判断连接是否无望（如果连续重传次数过多），并决定是否需要中止连接。 ii. 将 RTO 的值翻倍。 (c) 启动重传定时器，使其在翻倍后的 RTO 毫秒后到期。

7. 当接收方给发送方一个 ackno，确认成功接收到新数据（ackno 反映了一个大于任何之前 ackno 的绝对序列号）时： (a) 将 RTO 重置为“初始值”。 (b) 如果发送方有任何未确认的数据，则重新启动重传定时器，使其在 RTO 毫秒后到期（对于当前的 RTO 值）。 (c) 将“连续重传”计数重置为零。

## 实现TCPSender

基本思路：给定一个输出的 ByteStream，将其拆分成多个报文段，发送给接收方，如果它们没有被及时确认，就继续重传。

### 需要处理的四个基本事件，即四个API（每个事件都可能最终发送一个TCP段）
1. fill_window():  TCPSender 被要求填充窗口：它从输入的 ByteStream 中读取数据，并尽可能多地以 TCPSegment 的形式发送数据，只要还有新的字节可以读取并且窗口中有足够的空间。你需要确保每个发送的 TCPSegment 完全适配接收方的窗口。使每个 TCPSegment 尽可能大，但不超过 TCPConfig::MAX_PAYLOAD_SIZE（1452 字节）的大小。你可以使用 TCPSegment::length_in_sequence_space() 方法来计算一个报文段所占用的序列号总数。TCPSender 会维护一个成员变量 next_seqno，用来存储即将发送的绝对序列号，从零开始。每发送一个报文段，你都要将 next_seqno 增加报文段的长度，这样你就知道下一个报文段的序列号应该是多少。

2. ack_received(): 从接收方收到一个确认消息，传达窗口的左边界（即 ackno）和右边界（即 ackno + 窗口大小）。TCPSender 应该检查它的待确认报文段集合，并删除那些现在已经被完全确认的报文段（即，ackno 大于报文段中的所有序列号）。如果有新的空间被释放，TCPSender 可能需要再次填充窗口。如果 ackno 看起来无效，即确认了发送方尚未发送的数据，这个方法将返回 false。

3. tick(): 时间已经过去，TCPSender 会检查重传定时器是否到期，如果是的话，重传序列号最小的那个未确认报文段。

4. send_empty_segment():  TCPSender 应该生成并发送一个序列空间长度为零的 TCPSegment，并且正确设置序列号为 next_seqno。这在所有者（你下周将要实现的 TCPConnection）希望发送一个空的 ACK 报文段时很有用。这种类型的报文段——不携带数据且不占用任何序列号——不需要作为“待确认”报文段进行追踪，也不会被重传。